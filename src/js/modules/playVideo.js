export default class VideoPlayer {
    constructor(triggers, overlay) {
        this.btns = document.querySelectorAll(triggers);
        this.overlay = document.querySelector(overlay);
        this.close = this.overlay.querySelector('.close');
        this.onPlayerStateChange = this.onPlayerStateChange.bind(this); /* this.onPlayerStateChange так мы обращаемся к свойству 
которое будет внутри этого объекта. А дальше мы жестко привязываем контекст вызова к этому методу и собсвтенно к этому классу.
ТЕ мы забандили this !!! ЭТО ОЧЕНЬ ВАЖНО */
    }

    /* Теперь решим проблемы что открывается постоянно одно и то же видео. Нужно сделать что бы при клике на разные кнопк
подгружались разные видео. Начнем с то что переменую const path заменим на this path. Соотвественно если у нас еще не было вызванно
модельное окно(это все что находится в if), то мы создаем новое свойство this.path(инициализирующее свойство) которое принимает
data-url по той кнопки на который был клик и соотвественно мы будем создавать плеер и ьужа тоже передаем this.path*/
    bindTriggers() {
        this.btns.forEach((btn, i) => {
            /* Пропишем try catch потому НА ПЕРВОЙ СТРАНИЦЕ выскакивает ошибка у nextElementSibling потому что module__video-item
на первой странице просто не существует. ВСЕГДА НУЖНО ПРОВЕРЯТЬ КОД НА ДВУХ СТРАНИЦАХ ЕСЛИ МЫ ПИШЕМ ДВУХСТРАНИЧНЫЙ САЙТ ЧТО БЫ 
ПОСЛЕ КОДА НА ОДНОЙ СТРАНИЦЕ НЕ БЫЛО ОШИБОК ВО ВТОРОЙ*/
            try {
                /* Теперь только осталось реализовать что эти кнопки не будут активными которые там где замочек, что бы при клике на него 
не открывалось видео, потому что сейчас даже при клике на замочек плеер открывается ведь нет никакого фционала который
это бы запретил сделать.
    Логика такая что мы перебираем все кнопки и заблокированные и нет, и там уже поработает с атрибутами */
        const blockedElem = btn.closest('.module__video-item').nextElementSibling;

        if (i % 2 == 0) { /* Если номер кнопки будет без остатка делиться на два, то мы берем заблокированый блок и вручную назначаем атрибут  */
            blockedElem.setAttribute('data-disabled', 'true'); // тру поставили по логике что бы было правдивое значение что кнопка заблокированна
        } /*  И теперь весь код в btn.addEventListener мы вырезаем и помещаем в условие */
            } catch(e){}

            btn.addEventListener('click', () => { /*!btn.closest('.module__video-item') это мы сделали в конце урока как альтернативу
            try catch что бы блок весь не оборачивать проверить на наличие кнопки с таким классом */
                if (!btn.closest('.module__video-item') || btn.closest('.module__video-item').getAttribute('data-disabled') !== 'true' ) { /* тоесть если блок не заблокирован
то код спокойно выполниться.
ТЕПЕРЬ ПРИ КЛИКЕ НА ВТОРОЕ ВИДЕО ОНО НЕ ОТКРЫВАЕТСЯ ПОТОМУ ЧТО ЕМУ ПРИСВОЕНО АТРИБУТ data-disabled */

                    /* Теперь займемся фционалом что бы второй видео откроется ровно тогда как пользователь досмотрим первое
Так же важно что бы джаваскрипт понимал какое видео есть первое и на какой странице, потому что если пользователь досмотрим видео
на 1ом слайдере то ему на втором второе видео не может быть доступно. Будем использовать стороннее АПИ.
Вот здесь после того как мы кликнули на кнопку и открылся наш плеер */
                this.activeBtn = btn; // теперь мы точно знаем на какую кнопку кликнул пользователь и КАКАЯ КНОПКА СЛЕДУЕТ ЗА НЕЙ

                if (document.querySelector('iframe#frame')) {
                    this.overlay.style.display = 'flex';

                    /* Дальше мы понимаем что пользователь будет кликать и в другие кнопки c видео(их там 4) 
и появляется вопрос, нужно ли нам  каждый раз пересоздавать плеер если вдруг наш this.path поменялся. НА ЮТУБ АЙФРЕЙМ АПИ 
ЕСТЬ ТАКОЙ МЕТОД loadVideById. 
И теперь мы будем сравнивать дата-юрл кнопки по который кликнули и если он будет не равен то загрузим новое видео*/
                    if(this.path !== btn.getAttribute('data-url')) {
                        this.path = btn.getAttribute('data-url'); // благодаря этому коду мы точно знаем какое видео сейчас открыто
                        this.player.loadVideoById({videoId: this.path});                    }
                } else {
                    this.path = btn.getAttribute('data-url');

                    this.createPlayer(this.path);
                }
                }
            });
        });
    }

    bindCloseBtn() {
        this.close.addEventListener('click', () => { 
            this.overlay.style.display = 'none'; 
            this.player.stopVideo();
        });
    }

    /* сюда добавили events и его свойства для отслеживания статуса видео(как много уже проиграло, конец ли видео) */
    createPlayer(url) { 
        this.player = new YT.Player('frame', { 
            height: '100%',
            width: '100%',
            videoId: `${url}`,
            events: {
                'onStateChange': this.onPlayerStateChange // из-за того что мы внутри класса нужно обращаться к this
            }
        });

        this.overlay.style.display = 'flex'; 
    }

    // Будет срабатывать каждый раз после изменения состояния нашего плеера
    onPlayerStateChange(state) {
        try { // Та же история, на всякий случай обернем try catch
            /* НАБОР ДЕЙСТВИЙ: нам нужно убрать серый цвет с дива заблокированого видео, поменять текст с плс вотч на плей, убрать
серый цвет, поменять свг иконку замочка на свг иконку плей  */
        const blockedElem = this.activeBtn.closest('.module__video-item').nextElementSibling; // обращаемся к заблокированому блоку
        /* Метод closest() получает первую ноду по селеткору который мы сюда передадим выше по иерархии и если подходит элемент на котором
        это сработоло то он вернет сам элемент. ТЕ МЫ ПОЛУЧИМ ПЕРВОГО РОДИТЕЛЯ КОТОРЫЙ БУДЕТ У ЭТОГО БЛОКА this.activeBtn С ТАКИМ 
        СЕЛЕТОРОМ .module__video-item. У нас в верстке каждый модуль имеет такой селектор по этому мы никогда не получим андефайнд или нал.
        
        nextElementSibling - у нас есть элемент а мы получаем следущего по верстке, таким образом мы сможем переключится с одного видео 
        на другое */
        
        // теперь займемся svg иконкой плеера
        const playBtn = this.activeBtn.querySelector('svg').cloneNode(true);
        /* Метод cloneNode копирует ноду. Передаем параметр true потому что если мы использовем без параметра то клоуннод просто скопирует
        его поверхностно(с какими-то классами , атрибутами), а нам НУЖНО СКОПИРОВАТЬ ПОЛНОСТЬЮ ВСЕ ТО ЧТО НАХОДИТСЯ ВНУТРИ НАШЕГО ТЕГА
        ЗАХОДЯ В ТЕГ СВГ ТАМ БУДЕТ БОЛЕЕ СЛОЖНЫЕ КОНСТУРКЦИИ ТИПА ТЕГА path, всякие мелкие теги, и что бы все они полностью скопировались
        нам нужно включить глубокое копирование */
        
                // После того когда мы получили перемен с которыми будем взаимодействовать НУЖНО СКАЗАТЬ КОГДА ИМЕННО МЫ БУДЕМ ВСЕ ДЕЛАТЬ
        /* У ютуб апи есть свойства у стейт от -1 до 5 player.getPlayerState():Number
        Возвращает состояние проигрывателя. Возможные значения:
        -1 – воспроизведение видео не началось
        0 – воспроизведение видео завершено
        1 – воспроизведение
        2 – пауза
        3 – буферизация
        5 – видео находится в очереди */
        if (state.data === 0) { /* В самом начале есть фция onPlayerStateChange, она получает какой-то event(у нас этот параметр
        называет state) и у этого объекта есть свойство data и мы его используем */

            // теперь говорим какие действие будут при конце просмотра видео пользователем
            /* closed - это класс который находится у кружочка который его затеменяет непосредственно */
/* Здесь есть одна опасноть : мы пытаемя удалить класс closed и предпологаем что следующий элемент у нас закрыт, но бывает
так что пользователь опять открыл первое видео, досмотрел видео до конца, хотя у следующий секции этого класса уже не будет(кружочка)
По этому помещаем в условие еще одно условие */
            if(blockedElem.querySelector('.play__circle').classList.contains('closed')) {
                blockedElem.querySelector('.play__circle').classList.remove('closed');
                blockedElem.querySelector('svg').remove(); /* Удаляем значок замочка svg */
                blockedElem.querySelector('.play__circle').appendChild(playBtn); // Заменяем удаленный замочек на новую иконку плей
// playBtn - это скопированна полностью иконка плей с первого видео, она у нас в переменной
                blockedElem.querySelector('.play__text').textContent = 'play video'; /* Поменяем надпись сбоку видео с 
пожалуйста посмотрите первое видео на плей видео, и из-за того что у нас стоит текст трансформ аппер кейс, то плей видео 
будет в верхнем регистре */
                blockedElem.querySelector('.play__text').classList.remove('attention');/* теперь удалим класс атеншен который 
у нас изменяет стили */
                blockedElem.style.opacity = 1;/* теперь у самого элемента который был заблочен поменять стили фильтра и опасити */
                blockedElem.style.filter = 'none';
            }
        } /* Фционал готов, но теперь после того как у нас будет изменяться состояние onStateChange, у нас будет
        запускаться вот эта функция this.onPlayerStateChange и она будет обращаться к this но в this.onPlayerStateChange контекст будет
        теряться потому что мы это всё запускаем в новом экземпляре класса new YT.Player('frame', { 
                    height: '100%',
                    width: '100%',
                    videoId: `${url}`,
                    events: {
                        'onStateChange': this.onPlayerStateChange // из-за того что мы внутри класса нужно обращаться к this
                    }
        И что бы не было ошибок нам нужно ЖЕСТКО ПРИВЯЗАТЬ КОНТЕКСТ ВЫЗОВА ! ПО ЭТОМУ В КОНСТРУКТОРЕ ПРОПИШЕМ КОД */
        
                    // ТЕПЕРЬ В САМОМ КОНЦЕ УРОКА МЫ ПИШЕМ ФЦИОНАЛ ПО РАЗБЛОКИРОВКИ ВИДЕО
                    blockedElem.setAttribute('data-disabled', 'false'); /* Так что если видео закончилось мы у следующего блока уберем
         'data-disabled' , те он булет в фолс и все правильно сработает*/
        } catch(e){}
    }

    /* У нас возникла проблемы что плеер не обноваляется. Нужно проверить или у нас были какие-то кнопки переданы
У нас переменная btns пустой массив и мы можем его проверить на наличие элементов и если их нет то никакой 
фционал не нужно запускаь. Пэ всё помещаем в иф */
    init() {
         if (this.btns.length > 0) {
            const tag = document.createElement('script');

            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            
            this.bindTriggers(); 
            this.bindCloseBtn();
         }
    }
}  