import Slider from './slider';

export default class MiniSlider extends Slider {

    /* Нам понадобится сам слайдер, его обертка и кнопка навигации(некст, прев) */
    constructor(container, next, prev, activeClass, animate, autoplay) {
        super(container, next, prev, activeClass, animate, autoplay);
    }

    decorizeSlides() {
/* Берем активный класс и удаляем со всех слайдов внутри слайдера и назначаем только первому, каждому слайдеру на каждой странице*/
        this.slides.forEach(slide => {
            slide.classList.remove(this.activeClass);
// обрати внимание что в мейне я передавал актикласс без точки потому что здесь в жс classList работает без точки

            /* Точно так же как мы удаляли активный класс, мы должны переключать эти свойства, ведь когда слайд уже неактивен у него должно
все это погаснуть и опасити и стрелка. То-есть задаем свойства неактивным слайдам по умолчанию */
            if (this.animate) {
                slide.querySelector('.card__title').style.opacity = '0.4';
                slide.querySelector('.card__controls-arrow').style.opacity = '0';
            }
        });

        // Фикс Бага с кнопкой, скажем если активный слайд будет кнопкой то я не буду назначать ему класс активности
        if (!this.slides[0].closest('button')) { /* метод closest возвращаем родительский элемент либо самого себя, если он подходит
по селектору, в нашем случае батен. И если первый слайд будет кнопкой, то вернется true */
            this.slides[0].classList.add(this.activeClass); // добавляем первому активный класс
        } // те если наш первый активный слайд не является кнопкой, то мы ему добавляем активный класс
        
        if (this.animate) { // если свойство анимейт было передано
            this.slides[0].querySelector('.card__title').style.opacity = '1'; /* внутри первого слайда найдем определенные элементы 
            нам нужно активный слайд делать опасити с 0.4 на 1, по этому мы ищем элемент по класса в слайде.
            МЫ ЭТО ДЕЛАЕМ ДЛЯ ТОГО ЧТО БЫ У АКТИВНОГО СЛАЙДА ПОДСВЕЧИВАЛСЯ ЗАГОЛОВОК */

            this.slides[0].querySelector('.card__controls-arrow').style.opacity = '1'; /* В текущем слайде стрелка (card__controls-arrow) 
становится видимой. (через opacity)
Стрелка находится в диве card_controls и имеет свой класс card__control-arrow*/
        }
    }

    /* Создаем новый метод для автопереключение 2 слайдеру */
    /*  И во внутрь вырезаем и помещаем все что было в bindTriggers в кнопке next. ТАКИМ ОБРАЗОМ ЭТУ ФУНКИЮ МОЖНО СРАЗУ ИСПОЛЬЗОВАТЬ ВО
МНОГИХ МЕСТАХ. МЫ СРАЗУ ПЕРЕМЕЩАЕМСЯ В bindTriggers И this.next и там вызываем nextSlide, гениально ! */
    nextSlide() {
        // Фиксим баг с кнопкой, которые как слайдер
        if (this.slides[1].tagName == "BUTTON" && this.slides[2].tagName == "BUTTON") {/* Если на первой позиции и на второй кнопка */
            /* то мы будем не только первый слайд в конец перемещать, но и все кнопки в верстке прямо за ней */
            this.container.appendChild(this.slides[0]); // Slide c отзывом
            this.container.appendChild(this.slides[1]); // Btn
            this.container.appendChild(this.slides[2]); // Btn
/* Таким образом я проскачу что кнопкам назначается активный слайд и они становятся на первое место */
            this.decorizeSlides();
        } else if (this.slides[1].tagName == "BUTTON"){ /* Если пользователь будет ходить вперед назад стрелочками, то у него останиться
            только одна кнопка, которая будет на второй позиции */
            this.container.appendChild(this.slides[0]); // Slide
            this.container.appendChild(this.slides[1]); // Btn
/*То есть я перемещаю главный активный слайд и кнопку за ним в конец списка */
            this.decorizeSlides();
        } else { // если ниодно выше условие не выполнилось то мы просто выполняем действия которые были изначально
            /* когда мы переключаем слайд вперед, то наш первый элемент будет отправляться в конец списка  */
            this.container.appendChild(this.slides[0]);
/* appendChild - мы добавляем в конец списка определенный элемент, this.slides[0] - это наш первый элемент */
            this.decorizeSlides(); /* ПОМЕЩАЕМ ЗДЕСЬ ВЫЗОВ ФЦИИ. КОГДА БУДЕМ НАЖИМАТЬ НА СТРЕЛОЧКУ, У НАС БУДЕТ ВЫПОЛНЯТСЯ ТАК ЖЕ ДЕЙСТВИЕ
            УЖЕ СВЯЗАННЫЕ С КЛАССАМИ И ИНЛАЙН СТИЛЯМИ. В каждое условие if передаем  */
        }
    }

    /* Создадим фцию для привязки определенных действий к определенным кнопкам */
    bindTriggers() {
        this.next.addEventListener('click', () => this.nextSlide());

        this.prev.addEventListener('click', () => {

            /* Теперь исправим БАГ в prev */
            for (let i = this.slides.length - 1; i > 0; i--) {
/* в i помещаем все кство слайдов (this.slides.length - 1 МИНУС ПИШЕМ ПОТОМУ ЧТО ЭТО КЛАССИЧЕСКИЙ ПАТТЕРН ТАК КАК У 
НАС ЗДЕСЬ this.slides.length ВЫДАЕТ ЗНАЧЕНИЕ НА 1ЧКУ БОЛЬШЕ ЧЕМ НУМЕРАЦИЯ КОТОРАЯ ДОЛЖНА БЫТЬ В МАССИВЕ) */
        /* Мы перебираем массив с конца и если последний элемент который мы переберем (т-есть по обычному первый), будет кнопкой то
я его буду просто пропускать */
                if (this.slides[i].tagName !== "BUTTON") {
                    let active = this.slides[i];
/* [this.slides.length - 1] - это последний слайд в списке. НО МЫ ЕГО МОДИФИЦИРОВАЛИ ПОД i */

                    this.container.insertBefore(active, this.slides[0]);
                    /* так мы помещаем на 1ую позицию последний слайд 
                    active - это первый элемент который мы хотим поместить 
                    Второй аргумент - это перед кем поместить, те перед первым слайдом */

                    this.decorizeSlides(); // здесь тоже
                    break;/* так как это цикл то мы используем опператор break что б остановить цикл после того как 
выполниться this.decorizeSlides()
Говоря по русски: как только последний слайд у нас отправится на первую позицию и к нему применятся инлайн стили*/
                }
            }

           
        });
    }

    init() {
        this.container.style.cssText = `
            display: flex;
            flex-wrap: wrap;
            overflow: hidden;
            align-items: flex-start;
        `;
/* в виде cssText мы можем применять инлайн стили для наших элементов делаем мы это все для того что бы было правильное 
размещение на странице */

        this.bindTriggers();
        this.decorizeSlides();

        if (this.autoplay) { //если параметр аутоплей передан
            setInterval(() => this.nextSlide(), 5000); // таким образом делаем автопереключатель с интервалом в 5 секунд !
        }
    }
}